// String operations
String trimmed = text.trim();
String upper = text.toUpperCase();
String lower = text.toLowerCase();
boolean empty = text.isEmpty();
boolean blank = text.isBlank();
boolean contains = text.contains("search");
boolean starts = text.startsWith("prefix");
boolean ends = text.endsWith("suffix");
String replaced = text.replace("old", "new");
String[] parts = text.split(",");
String joined = String.join(", ", list);
String formatted = String.format("Hello %s, you are %d years old", name, age);

// StringBuilder
StringBuilder sb = new StringBuilder();
sb.append("Hello ");
sb.append(name);
sb.append("!");
String result = sb.toString();

// Collections initialization
List<String> list = new ArrayList<>();
List<String> immutable = List.of("a", "b", "c");
List<String> fromArray = Arrays.asList("a", "b", "c");

Map<String, Integer> map = new HashMap<>();
Map<String, Integer> immutableMap = Map.of("a", 1, "b", 2);

Set<String> set = new HashSet<>();
Set<String> immutableSet = Set.of("a", "b", "c");

// Collection operations
list.add(item);
list.addAll(otherList);
list.remove(item);
list.removeIf(i -> i.isEmpty());
list.clear();
list.contains(item);
list.indexOf(item);
list.size();
list.isEmpty();
list.get(0);
list.set(0, newValue);

Collections.sort(list);
Collections.reverse(list);
Collections.shuffle(list);
Collections.max(list);
Collections.min(list);
Collections.frequency(list, item);

// Map operations
map.put(key, value);
map.putAll(otherMap);
map.get(key);
map.getOrDefault(key, defaultValue);
map.remove(key);
map.containsKey(key);
map.containsValue(value);
map.keySet();
map.values();
map.entrySet();
map.computeIfAbsent(key, k -> createValue());
map.computeIfPresent(key, (k, v) -> updateValue(v));
map.merge(key, value, (oldV, newV) -> oldV + newV);

// Date/Time
LocalDate today = LocalDate.now();
LocalTime now = LocalTime.now();
LocalDateTime dateTime = LocalDateTime.now();
ZonedDateTime zoned = ZonedDateTime.now();
Instant instant = Instant.now();

LocalDate date = LocalDate.of(2024, 1, 15);
LocalDate parsed = LocalDate.parse("2024-01-15");

LocalDate tomorrow = today.plusDays(1);
LocalDate nextMonth = today.plusMonths(1);
LocalDate lastYear = today.minusYears(1);

boolean isBefore = date1.isBefore(date2);
boolean isAfter = date1.isAfter(date2);
long daysBetween = ChronoUnit.DAYS.between(date1, date2);

DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
String formatted = dateTime.format(formatter);
LocalDateTime parsed = LocalDateTime.parse(text, formatter);

// File operations
Path path = Path.of("file.txt");
Path path = Paths.get("directory", "file.txt");
String content = Files.readString(path);
List<String> lines = Files.readAllLines(path);
Files.writeString(path, content);
Files.write(path, lines);
Files.exists(path);
Files.isDirectory(path);
Files.createDirectories(path);
Files.delete(path);
Files.copy(source, target);
Files.move(source, target);

try (BufferedReader reader = Files.newBufferedReader(path)) {
    String line;
    while ((line = reader.readLine()) != null) {
        process(line);
    }
}

try (BufferedWriter writer = Files.newBufferedWriter(path)) {
    writer.write("content");
    writer.newLine();
}

// JSON with Jackson
ObjectMapper mapper = new ObjectMapper();
String json = mapper.writeValueAsString(object);
User user = mapper.readValue(json, User.class);
List<User> users = mapper.readValue(json, new TypeReference<List<User>>() {});

// JSON with Gson
Gson gson = new Gson();
String json = gson.toJson(object);
User user = gson.fromJson(json, User.class);

// HTTP Client (Java 11+)
HttpClient client = HttpClient.newHttpClient();
HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://api.example.com/users"))
    .header("Content-Type", "application/json")
    .GET()
    .build();
HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
int status = response.statusCode();
String body = response.body();

// Logging
private static final Logger log = LoggerFactory.getLogger(MyClass.class);
log.debug("Debug message: {}", value);
log.info("Info message");
log.warn("Warning: {}", message);
log.error("Error occurred", exception);

// Assertions
assert condition : "Error message";
Objects.requireNonNull(param, "param must not be null");

// Random
Random random = new Random();
int randomInt = random.nextInt(100);
double randomDouble = random.nextDouble();
boolean randomBoolean = random.nextBoolean();
List<Integer> shuffled = new ArrayList<>(list);
Collections.shuffle(shuffled, random);

// UUID
UUID uuid = UUID.randomUUID();
String uuidString = uuid.toString();
UUID parsed = UUID.fromString(uuidString);
// Builder Pattern
public class User {
    private final String name;
    private final String email;
    private final int age;

    private User(Builder builder) {
        this.name = builder.name;
        this.email = builder.email;
        this.age = builder.age;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private String name;
        private String email;
        private int age;

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Builder email(String email) {
            this.email = email;
            return this;
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }
}

User user = User.builder()
    .name("John")
    .email("john@example.com")
    .age(30)
    .build();

// Singleton Pattern
public class DatabaseConnection {
    private static volatile DatabaseConnection instance;
    private Connection connection;

    private DatabaseConnection() {
    }

    public static DatabaseConnection getInstance() {
        if (instance == null) {
            synchronized (DatabaseConnection.class) {
                if (instance == null) {
                    instance = new DatabaseConnection();
                }
            }
        }
        return instance;
    }

    public Connection getConnection() {
        return connection;
    }
}

// Factory Pattern
public interface Animal {
    void speak();
}

public class Dog implements Animal {
    @Override
    public void speak() {
        System.out.println("Woof!");
    }
}

public class Cat implements Animal {
    @Override
    public void speak() {
        System.out.println("Meow!");
    }
}

public class AnimalFactory {
    public static Animal createAnimal(String type) {
        if ("dog".equalsIgnoreCase(type)) {
            return new Dog();
        } else if ("cat".equalsIgnoreCase(type)) {
            return new Cat();
        }
        throw new IllegalArgumentException("Unknown animal type: " + type);
    }
}

Animal animal = AnimalFactory.createAnimal("dog");
animal.speak();

// Strategy Pattern
public interface PaymentStrategy {
    void pay(int amount);
}

public class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;

    public CreditCardPayment(String cardNumber) {
        this.cardNumber = cardNumber;
    }

    @Override
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using credit card");
    }
}

public class PayPalPayment implements PaymentStrategy {
    private String email;

    public PayPalPayment(String email) {
        this.email = email;
    }

    @Override
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using PayPal");
    }
}

public class ShoppingCart {
    private PaymentStrategy paymentStrategy;

    public void setPaymentStrategy(PaymentStrategy strategy) {
        this.paymentStrategy = strategy;
    }

    public void checkout(int amount) {
        paymentStrategy.pay(amount);
    }
}

// Observer Pattern
public interface Observer {
    void update(String message);
}

public interface Subject {
    void subscribe(Observer observer);
    void unsubscribe(Observer observer);
    void notifyObservers(String message);
}

public class NewsAgency implements Subject {
    private List<Observer> observers = new ArrayList<>();

    @Override
    public void subscribe(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void unsubscribe(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers(String message) {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }

    public void publishNews(String news) {
        notifyObservers(news);
    }
}

// Decorator Pattern
public interface Coffee {
    double getCost();
    String getDescription();
}

public class SimpleCoffee implements Coffee {
    @Override
    public double getCost() {
        return 2.0;
    }

    @Override
    public String getDescription() {
        return "Simple Coffee";
    }
}

public abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;

    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
}

public class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }

    @Override
    public double getCost() {
        return coffee.getCost() + 0.5;
    }

    @Override
    public String getDescription() {
        return coffee.getDescription() + ", Milk";
    }
}
// Optional Patterns

// Creating Optional
Optional<String> empty = Optional.empty();
Optional<String> present = Optional.of("value");
Optional<String> nullable = Optional.ofNullable(maybeNull);

// Basic usage
if (optional.isPresent()) {
    String value = optional.get();
    process(value);
}

optional.ifPresent(value -> process(value));
optional.ifPresent(this::process);

optional.ifPresentOrElse(
    value -> process(value),
    () -> handleEmpty()
);

// Default values
String result = optional.orElse("default");
String computed = optional.orElseGet(() -> computeDefault());
String required = optional.orElseThrow();
String custom = optional.orElseThrow(() -> new NotFoundException("Not found"));

// Transformations
Optional<Integer> length = optional.map(String::length);
Optional<User> user = optional.map(id -> userRepository.findById(id));

Optional<String> flat = optionalOptional.flatMap(Function.identity());
Optional<Address> address = user.flatMap(User::getAddress);

// Filtering
Optional<String> filtered = optional.filter(s -> s.length() > 5);
Optional<User> activeUser = user.filter(User::isActive);

// Chaining
String name = Optional.ofNullable(user)
    .map(User::getProfile)
    .map(Profile::getName)
    .orElse("Unknown");

int age = Optional.ofNullable(user)
    .filter(User::isActive)
    .map(User::getAge)
    .orElse(0);

// Converting to Stream
Stream<String> stream = optional.stream();

List<String> list = optionals.stream()
    .flatMap(Optional::stream)
    .collect(Collectors.toList());

// Pattern: Avoid null checks
// Before
if (user != null && user.getAddress() != null && user.getAddress().getCity() != null) {
    return user.getAddress().getCity();
}
return "Unknown";

// After
return Optional.ofNullable(user)
    .map(User::getAddress)
    .map(Address::getCity)
    .orElse("Unknown");

// Pattern: First non-empty
Optional<String> result = first
    .or(() -> second)
    .or(() -> third);

// Pattern: Handle both cases
return optional
    .map(value -> processSuccess(value))
    .orElseGet(() -> processEmpty());

// With repository
public User findOrCreate(Long id) {
    return userRepository.findById(id)
        .orElseGet(() -> userRepository.save(new User()));
}

// With validation
public void updateUser(Long id, UpdateRequest request) {
    User user = userRepository.findById(id)
        .orElseThrow(() -> new UserNotFoundException(id));
    user.setName(request.getName());
    userRepository.save(user);
}

// Combining optionals
Optional<String> combined = optionalA
    .flatMap(a -> optionalB.map(b -> a + b));

// Pattern: Return Optional from method
public Optional<User> findByEmail(String email) {
    return Optional.ofNullable(userMap.get(email));
}
// Spring Boot Controller Patterns

@RestController
@RequestMapping("/api/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping
    public ResponseEntity<List<User>> getAllUsers() {
        List<User> users = userService.findAll();
        return ResponseEntity.ok(users);
    }

    @GetMapping("/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        return userService.findById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    public ResponseEntity<User> createUser(@Valid @RequestBody CreateUserRequest request) {
        User user = userService.create(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(user);
    }

    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(@PathVariable Long id, @Valid @RequestBody UpdateUserRequest request) {
        return userService.update(id, request)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.delete(id);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/search")
    public ResponseEntity<List<User>> searchUsers(@RequestParam String query) {
        List<User> users = userService.search(query);
        return ResponseEntity.ok(users);
    }

    @GetMapping("/page")
    public ResponseEntity<Page<User>> getUsers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        Page<User> users = userService.findAll(PageRequest.of(page, size));
        return ResponseEntity.ok(users);
    }
}

// Service Layer
@Service
@Transactional
public class UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    public List<User> findAll() {
        return userRepository.findAll();
    }

    public Optional<User> findById(Long id) {
        return userRepository.findById(id);
    }

    public User create(CreateUserRequest request) {
        User user = new User();
        user.setName(request.getName());
        user.setEmail(request.getEmail());
        user.setPassword(passwordEncoder.encode(request.getPassword()));
        return userRepository.save(user);
    }

    public Optional<User> update(Long id, UpdateUserRequest request) {
        return userRepository.findById(id)
            .map(user -> {
                user.setName(request.getName());
                user.setEmail(request.getEmail());
                return userRepository.save(user);
            });
    }

    public void delete(Long id) {
        userRepository.deleteById(id);
    }
}

// Repository
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    Optional<User> findByEmail(String email);

    List<User> findByNameContaining(String name);

    @Query("SELECT u FROM User u WHERE u.active = true")
    List<User> findAllActive();

    @Query("SELECT u FROM User u WHERE u.role = :role")
    List<User> findByRole(@Param("role") String role);

    @Modifying
    @Query("UPDATE User u SET u.active = false WHERE u.id = :id")
    void deactivate(@Param("id") Long id);

    boolean existsByEmail(String email);

    long countByActive(boolean active);
}

// Entity
@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false)
    private boolean active = true;

    @Enumerated(EnumType.STRING)
    private Role role = Role.USER;

    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    private List<Order> orders = new ArrayList<>();

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id")
    private Department department;
}

// DTO
public record CreateUserRequest(
    @NotBlank String name,
    @Email @NotBlank String email,
    @Size(min = 8) String password
) {}

public record UpdateUserRequest(
    @NotBlank String name,
    @Email @NotBlank String email
) {}

public record UserResponse(
    Long id,
    String name,
    String email,
    boolean active
) {
    public static UserResponse from(User user) {
        return new UserResponse(
            user.getId(),
            user.getName(),
            user.getEmail(),
            user.isActive()
        );
    }
}

// Exception Handling
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException ex) {
        ErrorResponse error = new ErrorResponse("NOT_FOUND", ex.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex) {
        String message = ex.getBindingResult().getFieldErrors().stream()
            .map(e -> e.getField() + ": " + e.getDefaultMessage())
            .collect(Collectors.joining(", "));
        ErrorResponse error = new ErrorResponse("VALIDATION_ERROR", message);
        return ResponseEntity.badRequest().body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneral(Exception ex) {
        ErrorResponse error = new ErrorResponse("INTERNAL_ERROR", "An error occurred");
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}

// Configuration
@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
            .csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins("http://localhost:3000")
            .allowedMethods("GET", "POST", "PUT", "DELETE")
            .allowedHeaders("*")
            .allowCredentials(true);
    }
}

// Application Properties Pattern
@ConfigurationProperties(prefix = "app")
public class AppProperties {
    private String name;
    private String version;
    private Security security = new Security();

    public static class Security {
        private String jwtSecret;
        private long jwtExpiration;
    }
}

// Scheduled Tasks
@Component
public class ScheduledTasks {

    private final UserService userService;

    @Scheduled(fixedRate = 60000)
    public void cleanupInactiveUsers() {
        userService.cleanupInactive();
    }

    @Scheduled(cron = "0 0 2 * * ?")
    public void dailyReport() {
        // Run at 2 AM every day
    }
}
public class User {
private String name;
private String email;
private Long id;

public User() {
}

public User(String name, String email) {
this.name = name;
this.email = email;
}

public String getName() {
return name;
}

public void setName(String name) {
this.name = name;
}

public String getEmail() {
return email;
}

public void setEmail(String email) {
this.email = email;
}

public Long getId() {
return id;
}

public void setId(Long id) {
this.id = id;
}
}

public interface UserRepository {
User findById(Long id);
List<User> findAll();
User save(User user);
void delete(Long id);
}

public class UserService {
private UserRepository userRepository;

public UserService(UserRepository userRepository) {
this.userRepository = userRepository;
}

public User getUserById(Long id) {
return userRepository.findById(id);
}

public List<User> getAllUsers() {
return userRepository.findAll();
}

public User createUser(User user) {
return userRepository.save(user);
}

public void deleteUser(Long id) {
userRepository.delete(id);
}
}

for (int i = 0; i < list.size(); i++) {
System.out.println(list.get(i));
}

for (String item : items) {
process(item);
}

for (User user : users) {
user.setActive(true);
}

if (value != null) {
return value;
}

if (condition) {
return true;
} else {
return false;
}

if (user == null) {
throw new RuntimeException("User not found");
}

try {
operation();
} catch (Exception e) {
e.printStackTrace();
}

try {
User user = userService.findById(id);
return user;
} catch (Exception e) {
logger.error("Error finding user", e);
throw new RuntimeException(e);
}

while (condition) {
doSomething();
}

while (iterator.hasNext()) {
Item item = iterator.next();
process(item);
}

switch (type) {
case "A":
handleA();
break;
case "B":
handleB();
break;
default:
handleDefault();
}

private static final Logger logger = LoggerFactory.getLogger(UserService.class);

@Autowired
private UserService userService;

@Override
public String toString() {
return "User{name=" + name + ", email=" + email + "}";
}

@GetMapping("/{id}")
public ResponseEntity<User> getUser(@PathVariable Long id) {
User user = userService.findById(id);
return ResponseEntity.ok(user);
}

@PostMapping
public ResponseEntity<User> createUser(@RequestBody User user) {
User created = userService.save(user);
return ResponseEntity.status(HttpStatus.CREATED).body(created);
}

public static void main(String[] args) {
System.out.println("Hello World");
}

public static void main(String[] args) {
SpringApplication.run(Application.class, args);
}

List<String> list = new ArrayList<>();
Map<String, Integer> map = new HashMap<>();
Set<String> set = new HashSet<>();

String name = request.getParameter("name");
String value = System.getProperty("key");
String env = System.getenv("ENV_VAR");
// Stream API Patterns

// filter
List<User> activeUsers = users.stream()
    .filter(user -> user.isActive())
    .collect(Collectors.toList());

List<String> longNames = names.stream()
    .filter(name -> name.length() > 5)
    .collect(Collectors.toList());

// map
List<String> userNames = users.stream()
    .map(User::getName)
    .collect(Collectors.toList());

List<Integer> lengths = strings.stream()
    .map(String::length)
    .collect(Collectors.toList());

List<UserDto> dtos = users.stream()
    .map(user -> new UserDto(user.getName(), user.getEmail()))
    .collect(Collectors.toList());

// flatMap
List<String> allWords = sentences.stream()
    .flatMap(sentence -> Arrays.stream(sentence.split(" ")))
    .collect(Collectors.toList());

// sorted
List<User> sortedUsers = users.stream()
    .sorted(Comparator.comparing(User::getName))
    .collect(Collectors.toList());

List<User> sortedByAge = users.stream()
    .sorted(Comparator.comparingInt(User::getAge).reversed())
    .collect(Collectors.toList());

// distinct
List<String> uniqueNames = names.stream()
    .distinct()
    .collect(Collectors.toList());

// limit and skip
List<User> topFive = users.stream()
    .limit(5)
    .collect(Collectors.toList());

List<User> afterSkip = users.stream()
    .skip(10)
    .limit(5)
    .collect(Collectors.toList());

// findFirst and findAny
Optional<User> firstUser = users.stream()
    .filter(u -> u.getAge() > 18)
    .findFirst();

Optional<User> anyUser = users.stream()
    .filter(u -> u.isActive())
    .findAny();

// anyMatch, allMatch, noneMatch
boolean hasAdmin = users.stream()
    .anyMatch(u -> u.getRole().equals("ADMIN"));

boolean allActive = users.stream()
    .allMatch(User::isActive);

boolean noneDeleted = users.stream()
    .noneMatch(User::isDeleted);

// count
long activeCount = users.stream()
    .filter(User::isActive)
    .count();

// reduce
int sum = numbers.stream()
    .reduce(0, Integer::sum);

Optional<Integer> max = numbers.stream()
    .reduce(Integer::max);

String concatenated = strings.stream()
    .reduce("", (a, b) -> a + b);

// collect to different collections
Set<String> nameSet = users.stream()
    .map(User::getName)
    .collect(Collectors.toSet());

Map<Long, User> userMap = users.stream()
    .collect(Collectors.toMap(User::getId, Function.identity()));

Map<String, List<User>> groupedByRole = users.stream()
    .collect(Collectors.groupingBy(User::getRole));

Map<Boolean, List<User>> partitioned = users.stream()
    .collect(Collectors.partitioningBy(User::isActive));

String joined = names.stream()
    .collect(Collectors.joining(", "));

// statistics
IntSummaryStatistics stats = users.stream()
    .mapToInt(User::getAge)
    .summaryStatistics();

double average = users.stream()
    .mapToInt(User::getAge)
    .average()
    .orElse(0.0);

// parallel stream
List<Result> results = items.parallelStream()
    .map(this::process)
    .collect(Collectors.toList());

// peek for debugging
List<User> processed = users.stream()
    .filter(User::isActive)
    .peek(u -> System.out.println("Processing: " + u.getName()))
    .map(this::transform)
    .collect(Collectors.toList());

// Optional with stream
Optional<String> result = Optional.ofNullable(value)
    .map(String::toUpperCase)
    .filter(s -> s.length() > 3);

// Chaining operations
List<String> processedNames = users.stream()
    .filter(u -> u.getAge() >= 18)
    .filter(User::isActive)
    .sorted(Comparator.comparing(User::getName))
    .map(User::getName)
    .map(String::toUpperCase)
    .distinct()
    .limit(10)
    .collect(Collectors.toList());
// JUnit 5 Test Patterns

@Test
void shouldReturnTrueWhenConditionIsMet() {
    boolean result = service.check(validInput);
    assertTrue(result);
}

@Test
void shouldReturnFalseWhenConditionIsNotMet() {
    boolean result = service.check(invalidInput);
    assertFalse(result);
}

@Test
void shouldReturnExpectedValue() {
    String result = service.process("input");
    assertEquals("expected", result);
}

@Test
void shouldReturnNullWhenNotFound() {
    User result = service.findById(999L);
    assertNull(result);
}

@Test
void shouldReturnNonNullValue() {
    User result = service.findById(1L);
    assertNotNull(result);
}

@Test
void shouldThrowExceptionWhenInvalid() {
    assertThrows(IllegalArgumentException.class, () -> {
        service.process(null);
    });
}

@Test
void shouldThrowExceptionWithMessage() {
    Exception exception = assertThrows(NotFoundException.class, () -> {
        service.findById(999L);
    });
    assertEquals("User not found", exception.getMessage());
}

@Test
void shouldContainExpectedElements() {
    List<String> result = service.getItems();
    assertAll(
        () -> assertTrue(result.contains("item1")),
        () -> assertTrue(result.contains("item2")),
        () -> assertEquals(2, result.size())
    );
}

@Test
@DisplayName("should process valid input correctly")
void testValidInput() {
    Result result = service.process(validInput);
    assertThat(result).isNotNull();
    assertThat(result.getValue()).isEqualTo("expected");
}

// Parameterized Tests
@ParameterizedTest
@ValueSource(strings = {"a", "b", "c"})
void shouldAcceptValidValues(String value) {
    assertTrue(validator.isValid(value));
}

@ParameterizedTest
@CsvSource({
    "1, 2, 3",
    "4, 5, 9",
    "10, 20, 30"
})
void shouldAddNumbers(int a, int b, int expected) {
    assertEquals(expected, calculator.add(a, b));
}

@ParameterizedTest
@MethodSource("provideTestCases")
void shouldProcessTestCases(String input, String expected) {
    assertEquals(expected, service.process(input));
}

static Stream<Arguments> provideTestCases() {
    return Stream.of(
        Arguments.of("input1", "output1"),
        Arguments.of("input2", "output2")
    );
}

// Lifecycle methods
@BeforeEach
void setUp() {
    service = new UserService(mockRepository);
}

@AfterEach
void tearDown() {
    database.clear();
}

@BeforeAll
static void setUpClass() {
    testContainer.start();
}

@AfterAll
static void tearDownClass() {
    testContainer.stop();
}

// Mockito patterns
@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @InjectMocks
    private UserService userService;

    @Test
    void shouldFindUserById() {
        User user = new User(1L, "John");
        when(userRepository.findById(1L)).thenReturn(Optional.of(user));

        Optional<User> result = userService.findById(1L);

        assertTrue(result.isPresent());
        assertEquals("John", result.get().getName());
        verify(userRepository).findById(1L);
    }

    @Test
    void shouldSaveUser() {
        User user = new User(null, "John");
        User saved = new User(1L, "John");
        when(userRepository.save(any(User.class))).thenReturn(saved);

        User result = userService.create(user);

        assertNotNull(result.getId());
        verify(userRepository).save(user);
    }

    @Test
    void shouldDeleteUser() {
        doNothing().when(userRepository).deleteById(1L);

        userService.delete(1L);

        verify(userRepository).deleteById(1L);
    }

    @Test
    void shouldThrowWhenUserNotFound() {
        when(userRepository.findById(anyLong())).thenReturn(Optional.empty());

        assertThrows(NotFoundException.class, () -> {
            userService.getUser(999L);
        });
    }
}

// ArgumentCaptor
@Test
void shouldCaptureArgument() {
    ArgumentCaptor<User> captor = ArgumentCaptor.forClass(User.class);

    userService.create("John", "john@email.com");

    verify(userRepository).save(captor.capture());
    User captured = captor.getValue();
    assertEquals("John", captured.getName());
    assertEquals("john@email.com", captured.getEmail());
}

// Verify interactions
verify(mock).method();
verify(mock, times(2)).method();
verify(mock, never()).method();
verify(mock, atLeast(1)).method();
verify(mock, atMost(3)).method();
verifyNoMoreInteractions(mock);

// Spring Boot Test
@SpringBootTest
@AutoConfigureMockMvc
class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService userService;

    @Test
    void shouldReturnUser() throws Exception {
        User user = new User(1L, "John");
        when(userService.findById(1L)).thenReturn(Optional.of(user));

        mockMvc.perform(get("/api/users/1"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.name").value("John"));
    }

    @Test
    void shouldCreateUser() throws Exception {
        User user = new User(1L, "John");
        when(userService.create(any())).thenReturn(user);

        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"name\":\"John\",\"email\":\"john@email.com\"}"))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.id").value(1));
    }

    @Test
    void shouldReturnNotFound() throws Exception {
        when(userService.findById(999L)).thenReturn(Optional.empty());

        mockMvc.perform(get("/api/users/999"))
            .andExpect(status().isNotFound());
    }
}

// AssertJ fluent assertions
assertThat(result).isNotNull();
assertThat(result).isEqualTo(expected);
assertThat(list).hasSize(3);
assertThat(list).contains("item");
assertThat(list).containsExactly("a", "b", "c");
assertThat(list).isEmpty();
assertThat(string).startsWith("prefix");
assertThat(string).endsWith("suffix");
assertThat(string).contains("substring");
assertThat(number).isGreaterThan(5);
assertThat(number).isBetween(1, 10);
assertThat(optional).isPresent();
assertThat(optional).isEmpty();
